{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 소개\n\n### 1.1. 목적\n이 문서는 1953형제돼지국밥 프랜차이즈 및 직영점 관리 시스템에 대한 요구사항을 설명합니다. 본 시스템은 본사와 각 매장의 운영 효율화, 소통 강화, 전반적인 업무 효율 증진을 목표로 합니다.\n\n### 1.2. 목표\n*   수작업을 줄여 업무 효율성을 향상시킨다.\n*   효과적인 데이터 분석과 마케팅 전략을 통해 매출을 증대한다.\n*   본사와 가맹점 간 원활한 소통과 정보 공유로 관계를 강화한다.\n\n### 1.3. 대상 사용자\n*   본사 관리자\n*   가맹점/직영점 점주\n\n## 2. 목표 및 세부 목표\n\n### 2.1. 목표\n*   가맹점/직영점과 본사 간의 주문 프로세스를 간소화한다.\n*   실시간 매출 데이터 및 분석 정보를 제공하여 의사결정을 지원한다.\n*   본사와 가맹점/직영점 간의 소통과 정보 공유를 강화한다.\n\n### 2.2. 세부 목표\n*   주문 및 재고관리 관련 수작업을 50% 이상 감소시킨다.\n*   시스템 도입 1년 이내 전체 매출을 10% 증가시킨다.\n*   가맹점주들의 소통 만족도를 20% 향상시킨다.\n\n## 3. 주요 기능\n\n### 3.1. 핵심 기능\n*   **매출 대시보드 (페이히어 API 연동):**\n    *   실시간 매출 데이터 시각화\n    *   목표 대비 매출 실적 추적\n    *   페이히어 API 연동을 통한 자동 데이터 수집\n*   **주문 관리 (이카운트 API 연동):**\n    *   주문 자동화 및 추적\n    *   이카운트 API 연동을 통한 원활한 재고 관리\n    *   주문 상태 변경 시 자동 알림 제공\n*   **공지사항:**\n    *   본사에서 모든 매장에 중요한 공지사항을 전달하는 중앙화된 플랫폼\n    *   특정 매장 또는 매장 그룹 대상으로 안내 가능\n    *   공지사항 조회 및 확인 여부 추적\n*   **품질 관리 및 위생 점검:**\n    *   정기적인 품질 및 위생 점검 체크리스트 제공\n    *   점검 결과 기록 및 보관\n    *   문제 발생 시 즉각적인 조치 알림\n*   **교육 자료 및 매뉴얼:**\n    *   교육 자료, 매뉴얼, 동영상을 중앙에서 관리\n    *   가맹점 및 직영점 직원이 쉽게 접근 가능\n\n### 3.2. 추가 기능\n*   **레시피 관리:** 표준화된 레시피를 관리 및 배포\n*   **실시간 알림:** 주요 업데이트 및 리마인더에 대한 즉각적 알림 제공\n\n## 4. 사용자 스토리\n\n### 4.1. 본사 관리자\n*   본사 관리자로서 모든 매장의 실시간 매출 실적을 모니터링하여 부진 매장을 파악하고 개선 방안을 논의하고 싶다.\n*   본사 관리자로서 가맹점의 주문 요청을 확인하고 이카운트 API로 처리하여 신속하고 정확한 주문 처리를 보장하고 싶다.\n*   본사 관리자로서 중요한 공지사항을 전체 매장에 게시하여 최신 정보를 모두에게 전달하고 싶다.\n\n### 4.2. 가맹점/직영점 점주\n*   점주로서 매일/주간 단위로 매장 매출 데이터를 확인하여 목표 대비 실적을 평가하고 싶다.\n*   점주로서 본사에 물품을 주문하고 주문 상태를 추적하여 재고를 효과적으로 관리하고 싶다.\n*   점주로서 중요한 공지사항과 업데이트를 실시간으로 받아 최신 정보를 놓치지 않고 싶다.\n\n## 5. 기술 요구사항\n\n### 5.1. API 연동\n*   매출 데이터 수집을 위한 페이히어 API 연동\n*   주문 및 재고 관리를 위한 이카운트 API 연동\n\n### 5.2. 플랫폼\n*   웹 기반 (반응형)\n\n### 5.3. 보안\n*   안전한 인증 및 권한 관리\n*   데이터 저장 및 전송 시 암호화 적용\n\n## 6. 출시 기준\n\n### 6.1. 완료 정의\n*   모든 핵심 기능이 완전히 구현 및 테스트됨\n*   시스템이 페이히어 및 이카운트 API와 연동됨\n*   사용자 인수 테스트(UAT)가 만족스럽게 완료됨\n\n## 7. 향후 고려사항\n\n### 7.1. 확장성\n*   시스템은 향후 매장 및 사용자 수 증가를 고려하여 설계되어야 함\n\n### 7.2. 고급 기능\n*   고급 분석 및 리포팅 기능 도입 검토\n*   AI 기반 예측 분석 및 추천 기능 연동 가능성 탐색",
      "writedAt": "2025-11-09T06:19:55.304Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n  \n## Tech Stack\n\nNext.js 15, shadcn, lucide-react, typescript, tailwindcss, supabase, @tanstack/react-query, es-toolkit, date-fns, Supabase Auth, 결제 처리\n\n## Directory Structure\n\n\n/\n├── src/\n│   ├── app/                    # Next.js app router\n│   ├── components/             # common components\n│   │   └── ui/                 # shadcn/ui components\n│   ├── features/               # custom hooks (handle business logic)\n│   │   └── [featureName]/      # feature-based directory\n│   │   │   └── components/     # feature-based components\n│   │   │   └── hooks/          # feature-based hooks\n│   │   │   └── lib/            # feature-based lib\n│   │   │   └── pages/          # feature-based page components\n│   │   │   └── api.ts          # feature-based api callers\n│   │   │   └── schema.ts       # feature-based api schemas (zod)\n│   │   │   └── constants.ts    # feature-based constants\n│   │   │   └── types.ts        # feature-based types\n│   │   │   └── utils.ts        # feature-based utils\n│   │   └── ...                 # other features\n│   ├── hooks/                  # common hooks\n│   ├── lib/                    \n│   │   └── utils.ts            # shadcn cn utility function\n├── public/                     # static assets\n└── supabase/migrations         # supabase migrations (0000_name.sql)\n\n  ",
      "writedAt": "2025-11-09T06:19:55.304Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-11-09T06:19:55.304Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-11-09T06:19:55.304Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-11-09T06:19:55.304Z"
    }
  ]
}